0
00:00:05,650 --> 00:00:08,090
Welcome to Software Testing.

1
00:00:08,090 --> 00:00:11,050
After watching this video, you will be able to:

2
00:00:11,050 --> 00:00:16,660
Define the terms functional testing, non-functional testing, regression testing  and

3
00:00:16,660 --> 00:00:20,970
Compare and contrast typical testing levels .

4
00:00:20,970 --> 00:00:25,869
Software Testing is the practice of integrating quality checks throughout the software development

5
00:00:25,869 --> 00:00:26,869
cycle.

6
00:00:26,869 --> 00:00:28,130
The purpose of testing is to

7
00:00:28,130 --> 00:00:31,869
check whether the software matches expected requirements and

8
00:00:31,869 --> 00:00:34,860
ensure error-free software.

9
00:00:34,860 --> 00:00:39,000
In order to test software, the team writes “test cases.”

10
00:00:39,000 --> 00:00:43,949
These test cases are written to verify the functionality of a software application

11
00:00:43,949 --> 00:00:47,507
and ensure requirements have been satisfied.

12
00:00:47,507 --> 00:00:53,640
Test cases can be written in different stages of the SDLC and may vary depending on the

13
00:00:53,640 --> 00:01:00,050
type of test or the method used to develop the software, such as Agile or waterfall.

14
00:01:00,050 --> 00:01:01,700
A test case contains:

15
00:01:01,700 --> 00:01:02,337
steps,

16
00:01:02,337 --> 00:01:03,255
inputs,

17
00:01:03,255 --> 00:01:04,189
data, and

18
00:01:04,189 --> 00:01:10,338
the expected corresponding outputs. Regardless of the test type or development method, test cases

19
00:01:10,470 --> 00:01:13,990
should always be written after requirements are finalized.

20
00:01:13,990 --> 00:01:20,690
Software testing helps evaluate the software to identify whether or not the software product

21
00:01:20,690 --> 00:01:24,180
meets requirements and is error-free.

22
00:01:24,180 --> 00:01:28,660
Types of testing can be broadly classified into three categories:

23
00:01:28,660 --> 00:01:30,100
Functional testing

24
00:01:30,100 --> 00:01:31,810
Non-Functional testing

25
00:01:31,810 --> 00:01:32,950
Regression testing

26
00:01:32,950 --> 00:01:38,380
Functional testing usually involves black box testing which is a method of testing

27
00:01:38,380 --> 00:01:42,870
without looking at source code or internal structure.

28
00:01:42,870 --> 00:01:46,570
Functional testing is only concerned with inputs and corresponding

29
00:01:46,570 --> 00:01:53,549
outputs of the system under test, also called the SUT. It is entirely based on testing functional

30
00:01:53,549 --> 00:01:54,960
requirements.

31
00:01:54,960 --> 00:01:57,510
Functional testing can be carried out manually or

32
00:01:57,510 --> 00:01:59,909
using automated tools.

33
00:01:59,909 --> 00:02:05,140
The goal is to test the functionality of the application making sure the application is

34
00:02:05,140 --> 00:02:06,170
usable and

35
00:02:06,170 --> 00:02:13,540
accessible. Functional testing tests the SUT, to make sure it meets functional requirements.

36
00:02:13,540 --> 00:02:18,549
Functional testing makes certain that when user errors or input edge cases do occur,

37
00:02:18,549 --> 00:02:21,599
the software handles those exceptions seamlessly by

38
00:02:21,599 --> 00:02:25,064
displaying appropriate error messages.

39
00:02:25,064 --> 00:02:29,319
Non-functional testing includes testing the application for attributes like

40
00:02:29,319 --> 00:02:30,319
performance,

41
00:02:30,319 --> 00:02:31,319
security,

42
00:02:31,319 --> 00:02:32,319
scalability, and

43
00:02:32,319 --> 00:02:38,269
availability. Non-functional testing checks to see if the SUTs non-functional behavior

44
00:02:38,269 --> 00:02:40,239
is performing properly.

45
00:02:40,239 --> 00:02:44,489
Non-functional testing should answer questions like the following:

46
00:02:44,489 --> 00:02:47,579
How does the application behave under stress?

47
00:02:47,579 --> 00:02:51,590
What happens when many users log in at the same time?

48
00:02:51,590 --> 00:02:56,250
Are the instructions in documents and user manuals consistent with the application’s

49
00:02:56,250 --> 00:02:57,250
behavior?

50
00:02:57,250 --> 00:03:02,180
Does the application behave similarly under different operating systems?

51
00:03:02,180 --> 00:03:05,779
How does the application handle disaster recovery?

52
00:03:05,779 --> 00:03:09,420
How secure is the application?

53
00:03:09,420 --> 00:03:14,099
Regression testing, also called maintenance testing, confirms that a recent change to

54
00:03:14,099 --> 00:03:15,310
the application,

55
00:03:15,310 --> 00:03:17,879
such as a bug fix, does not adversely

56
00:03:17,879 --> 00:03:21,620
affect already existing functionality.

57
00:03:21,620 --> 00:03:26,059
Regression testing should occur when there has been a change in requirements or when

58
00:03:26,059 --> 00:03:28,430
defects have been fixed.

59
00:03:28,430 --> 00:03:33,749
In order to conduct regression testing, all or some of the test cases should be selected

60
00:03:33,749 --> 00:03:39,769
to test against the application. Regression test case selection and prioritization can

61
00:03:39,769 --> 00:03:43,980
be challenging and can depend on several factors.

62
00:03:43,980 --> 00:03:48,260
Common reasons for regression test case selection include cases that:

63
00:03:48,260 --> 00:03:49,769
have frequent defects ,

64
00:03:49,769 --> 00:03:52,140
contain frequently used functionality,

65
00:03:52,140 --> 00:03:54,659
contain features with recent changes,

66
00:03:54,659 --> 00:03:56,529
or are complex test cases,

67
00:03:56,529 --> 00:03:57,900
edge cases, and

68
00:03:57,900 --> 00:04:01,609
randomly successful or failed test cases.

69
00:04:01,609 --> 00:04:06,950
Now that we have discussed different types of testing, let’s discuss testing levels.

70
00:04:06,950 --> 00:04:08,959
There are four testing levels:

71
00:04:08,959 --> 00:04:09,959
unit,

72
00:04:09,959 --> 00:04:10,959
integration,

73
00:04:10,959 --> 00:04:11,959
system, and

74
00:04:11,959 --> 00:04:12,959
acceptance.

75
00:04:12,959 --> 00:04:18,680
Each level occurs at a different time in the SDLC. There are 4 different levels in order

76
00:04:18,680 --> 00:04:24,759
to reduce the amount of time spent on testing by preventing overlap. We will discuss each

77
00:04:24,759 --> 00:04:28,050
of these testing levels next.

78
00:04:28,050 --> 00:04:33,700
Unit testing refers to tests that verify the functionality of a specific section of code,

79
00:04:33,700 --> 00:04:35,780
usually at the function level.

80
00:04:35,780 --> 00:04:40,800
It is performed by the software developer or engineer during the development phase of

81
00:04:40,800 --> 00:04:43,490
the software development life cycle.

82
00:04:43,490 --> 00:04:48,759
Unit testing aims to eliminate construction errors before code is integrated with other

83
00:04:48,759 --> 00:04:54,680
modules. Unit testing is intended to increase the quality of the resulting software as well

84
00:04:54,680 --> 00:04:59,590
as the efficiency of the overall development process.

85
00:04:59,590 --> 00:05:00,590
Integration testing

86
00:05:00,590 --> 00:05:07,289
seeks to identify errors when two or more smaller, independent code modules are combined.

87
00:05:07,289 --> 00:05:10,919
Integration testing is another type of black-box testing.

88
00:05:10,919 --> 00:05:16,009
Prior to integration testing, smaller, independent code modules that passed unit

89
00:05:16,009 --> 00:05:20,930
testing are incorporated into the larger software application.

90
00:05:20,930 --> 00:05:26,889
After modules are integrated together, then integration testing can occur.

91
00:05:26,889 --> 00:05:31,800
Integration testing exposes bugs that occur when those smaller units of code interact

92
00:05:31,800 --> 00:05:33,810
with each other.

93
00:05:33,810 --> 00:05:36,970
Integration testing uncovers deficiencies in communication with

94
00:05:36,970 --> 00:05:39,319
a new module in conjunction with

95
00:05:39,319 --> 00:05:41,300
other existing modules,

96
00:05:41,300 --> 00:05:42,300
databases, or

97
00:05:42,300 --> 00:05:48,580
external hardware. Integration testing uncovers situations where bugs develop due to differing

98
00:05:48,580 --> 00:05:55,050
programming logic between modules, for instance. Also, sometimes during module development,

99
00:05:55,050 --> 00:06:00,909
requirements change, and the module isn’t fully unit tested. Poor exception handling

100
00:06:00,909 --> 00:06:04,990
can cause problems when modules are integrated together.

101
00:06:04,990 --> 00:06:10,979
System testing occurs after integration testing and is conducted on a complete, integrated

102
00:06:10,979 --> 00:06:11,979
system to

103
00:06:11,979 --> 00:06:15,199
evaluate the system's compliance with its specified requirements.

104
00:06:15,199 --> 00:06:20,939
It validates the system as a fully completed software product.

105
00:06:20,939 --> 00:06:25,479
System testing is both functional and non-functional.

106
00:06:25,479 --> 00:06:30,439
System testing is done in a staging environment, which should be similar to the production

107
00:06:30,439 --> 00:06:33,229
environment. And finally,

108
00:06:33,229 --> 00:06:38,840
acceptance testing is formal testing with respect to user needs, requirements, and business

109
00:06:38,840 --> 00:06:43,500
processes. It determines whether a system satisfies the needs of the

110
00:06:43,500 --> 00:06:44,500
users,

111
00:06:44,500 --> 00:06:45,500
customers, and

112
00:06:45,500 --> 00:06:51,129
other stakeholders. Acceptance testing is usually done by the customer or the stakeholders

113
00:06:51,129 --> 00:06:55,539
during the maintenance stage of the SDLC.

114
00:06:55,539 --> 00:06:57,629
In this video you learned that:

115
00:06:57,629 --> 00:07:03,379
There are three categories of testing: functional, non-functional, and regression .

116
00:07:03,379 --> 00:07:07,409
Unit testing verifies small, independent chunks of code.

117
00:07:07,409 --> 00:07:13,210
Integration testing looks for errors when two or more small chunks of code are combined.

118
00:07:13,210 --> 00:07:18,770
System testing validates the system as a fully completed software product and

119
00:07:18,770 --> 00:07:27,969
acceptance testing verifies correct implementation of user requirements and business processes.

